#include <stdio.h>
#include <stdlib.h>

#include <comp.h>
#include <parse.h>
#include <flagspec.h>
#include <files.h>
#include <common.h>

static void compile_info_header(FILE *outfile_handle){
    fputs("/* Generated by gonf v" VERSION " */\n\n", outfile_handle);
}

/* Compile identifier macros.
 *
 * EXAMPLE_OUTPUT:
 *  #define GONFLAG_INDEX(IDENTIFIER) GONFLAG_##IDENTIFIER
 *  #define GONFLAG_SAMPLE 0
 */
static void compile_gonf_identifiers(struct flagspec *flags, FILE *outfile_handle){
    struct flaginfo flag;

    fputs("#define GONFLAG_INDEX(IDENTIFIER) GONFLAG_##IDENTIFIER\n", outfile_handle);
    for(flagc_t flagi = 0; flagi < flagspec_len(flags); flagi++){
        flag = flagspec_at(flags, flagi);
        if(flag.identifier != NULL)
            fprintf(
                outfile_handle, 
                "#define GONFLAG_%s %d\n", 
                flag.identifier,
                flagi
            );
    }
}

/* Compile the GONFLAGC macro. */
static void compile_gonflagc(flagc_t flagspec_len, FILE *outfile_handle){
    fprintf(outfile_handle, "\n#define GONFLAGC %d\n\n", flagspec_len);
}

/* Compile a multiline string into C format,
 * replacing control chars with their corresponding 
 * representations.
 */
static void compile_multiline_str(char *str, FILE *outfile_handle){
    char c;
    putc('\"', outfile_handle);
    while((c = *(str++)) != '\0'){
        switch(c){
        case '\n':   fputs("\\n\"\n\t\"", outfile_handle);  break;
        case '\t':   fputs("\\t", outfile_handle);          break;
        case '\x01'...'\x08':
        case '\x13'...'\x1f': 
        case '\x7f': fprintf(outfile_handle, "\\x%02x", c); break;
        default:     fprintf(outfile_handle, "%c", c);      break;
        }
    }
    fputs("\", ", outfile_handle);
}

/* Compile the gonf_flags struct.
 *
 * EXAMPLE OUTPUT:
 * static struct gonflag gonf_flags[GONFLAGC] = {
 *  {"value", NULL, "sample", "sample", 0, 'g', true},
 * };
 */
static void compile_gonf_flags(struct flagspec *flags, FILE *outfile_handle){
    struct flaginfo flag;

    fputs("static struct gonflag gonf_flags[GONFLAGC] = {\n", outfile_handle);
    for(flagc_t flagi = 0; flagi < flagspec_len(flags); flagi++){
        flag = flagspec_at(flags, flagi);

        fputs("\t{", outfile_handle);
        if(flag.value != NULL)               compile_multiline_str(flag.value, outfile_handle);
        else                                 fputs("NULL, ", outfile_handle);

        fputs("NULL, ", outfile_handle);

        if(flag.description != NULL)         compile_multiline_str(flag.description, outfile_handle);
        else                                 fputs("NULL, ", outfile_handle);

        if(flag.longname != NULL)            fprintf(outfile_handle, "\"%s\", ", flag.longname);
        else                                 fputs("NULL, ", outfile_handle);

        fputs("0, ", outfile_handle);

        if(flag.shortname != FLAGSHORT_NULL) fprintf(outfile_handle, "'%c', ", flag.shortname);
        else                                 fputs("GONFSHORT_NULL, ", outfile_handle);

        if(flag.is_value)                    fputs("true},\n", outfile_handle);
        else                                 fputs("false},\n", outfile_handle);
    }
    fputs("};\n\n", outfile_handle);
}

/* Compile the gonf_flags_by_short struct.
 *
 * EXAMPLE OUTPUT:
 * static const gonfc_t gonf_flags_by_short[94] = {
 *  [4] = 1,
 * };
 */
static void compile_gonf_flags_by_short(struct flagspec *flags, FILE *outfile_handle){
    flagc_t shortn;

    fputs("static const gonfc_t gonf_flags_by_short["XSTR(FLAGSHORT_MAX)"] = {\n", outfile_handle);\
    for(flagc_t i = 0; i < FLAGSHORT_MAX; i++){
        shortn = flags->shortname_record[i];
        if(shortn != 0){
            fprintf(outfile_handle, "\t[%d] = %d,\n", i, shortn);
        }
    }
    fputs("};\n\n", outfile_handle);
}

/* Compile the gonf_flags_by_long struct.
 *
 * EXAMPLE OUTPUT:
 * static struct gonf_matchlist gonf_flags_by_long[GONFLAGC] = {
 *  {0, "sample", gonf_flags_by_long},
 * };
 */
static void compile_gonf_flags_by_long(struct flagspec *flags, FILE *outfile_handle){
    struct flaginfo flag;
    flagc_t longc, long_last;

    fputs("static struct gonf_matchlist gonf_flags_by_long[GONFLAGC] = {\n", outfile_handle);

    longc = 0;
    long_last = flags->longname_record->len;
    for(flagc_t flagi = 0; flagi < flagspec_len(flags); flagi++){
        flag = flagspec_at(flags, flagi);
        if(flag.longname != NULL){
            longc++;
            if(longc == long_last){
                fprintf(outfile_handle, 
                    "\t{%d, \"%s\", gonf_flags_by_long},\n"
                    "};\n\n",
                    flagi,
                    flag.longname
                );
                break;
            }else
                fprintf(outfile_handle, 
                    "\t{%d, \"%s\", gonf_flags_by_long + %d},\n", 
                    flagi,
                    flag.longname,
                    longc
                );
        }
    }
}

/* Compile the flagspec into a C library header in outfile. */
static void compile_header(struct flagspec *flags, struct file outfile){
    /* write header */
    compile_info_header(outfile.handle);
    fwrite(gonf_head_h_dump, 1, gonf_head_h_dump_len, outfile.handle);

    compile_gonflagc(flagspec_len(flags), outfile.handle);
    compile_gonf_identifiers(flags, outfile.handle);

    /* write tail */
    fwrite(gonf_tail_h_dump, 1, gonf_tail_h_dump_len, outfile.handle);
}

/* Compile the flagspec into a C library in outfile */
static void compile_library(struct flagspec *flags, struct file outfile){
    /* write header */
    compile_info_header(outfile.handle);
    fwrite(gonf_head_c_dump, 1, gonf_head_c_dump_len, outfile.handle);

    compile_gonflagc(flagspec_len(flags), outfile.handle);
    compile_gonf_identifiers(flags, outfile.handle);
    compile_gonf_flags(flags, outfile.handle);
    compile_gonf_flags_by_short(flags, outfile.handle);
    compile_gonf_flags_by_long(flags, outfile.handle);

    /* write tail */
    fwrite(gonf_tail_c_dump, 1, gonf_tail_c_dump_len, outfile.handle);
}

int compilegonf(struct filearr *infiles, struct file outfile, struct file header_outfile){
    struct flagspec *flags;
    int ret;
    
    flags = flagspec_new();
    if(flags == NULL)
        return ERR_NOMEM;

    ret = parsegonf(infiles, flags);

    if(ret != OK){
        flagspec_free(flags);
        return ret;
    }
    if(flagspec_len(flags) == 0){
        flagspec_free(flags);
        return ERR_NOFLAGS;
    }
    if(filearr_check_errors(infiles) == ERR_FILE){
        flagspec_free(flags);
        return ERR_FILE;
    }

    compile_library(flags, outfile);
    
    if(file_error_check(outfile) == ERR_FILE){
        flagspec_free(flags);
        return ERR_FILE;
    }

    if(header_outfile.handle != NULL){
        compile_header(flags, header_outfile);

        if(file_error_check(header_outfile) == ERR_FILE){
            flagspec_free(flags);
            return ERR_FILE;
        }
    }

    flagspec_free(flags);
    return OK;
}
        